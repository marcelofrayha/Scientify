"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defenderDeploy = void 0;
const contract_names_1 = require("hardhat/utils/contract-names");
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const build_info_v5_json_1 = __importDefault(require("@openzeppelin/upgrades-core/artifacts/build-info-v5.json"));
const ERC1967Proxy_json_1 = __importDefault(require("@openzeppelin/upgrades-core/artifacts/@openzeppelin/contracts-v5/proxy/ERC1967/ERC1967Proxy.sol/ERC1967Proxy.json"));
const BeaconProxy_json_1 = __importDefault(require("@openzeppelin/upgrades-core/artifacts/@openzeppelin/contracts-v5/proxy/beacon/BeaconProxy.sol/BeaconProxy.json"));
const UpgradeableBeacon_json_1 = __importDefault(require("@openzeppelin/upgrades-core/artifacts/@openzeppelin/contracts-v5/proxy/beacon/UpgradeableBeacon.sol/UpgradeableBeacon.json"));
const TransparentUpgradeableProxy_json_1 = __importDefault(require("@openzeppelin/upgrades-core/artifacts/@openzeppelin/contracts-v5/proxy/transparent/TransparentUpgradeableProxy.sol/TransparentUpgradeableProxy.json"));
const utils_1 = require("./utils");
const debug_1 = __importDefault(require("../utils/debug"));
const deploy_impl_1 = require("../utils/deploy-impl");
const upgrades_core_2 = require("@openzeppelin/upgrades-core");
const client_1 = require("./client");
const deployableProxyContracts = [ERC1967Proxy_json_1.default, BeaconProxy_json_1.default, UpgradeableBeacon_json_1.default, TransparentUpgradeableProxy_json_1.default];
async function defenderDeploy(hre, factory, opts, ...args) {
    const client = (0, client_1.getDeployClient)(hre);
    const constructorArgs = [...args];
    const contractInfo = await getContractInfo(hre, factory, { constructorArgs, ...opts });
    const network = await (0, utils_1.getNetwork)(hre);
    (0, debug_1.default)(`Network ${network}`);
    const verifySourceCode = opts.verifySourceCode ?? true;
    (0, debug_1.default)(`Verify source code: ${verifySourceCode}`);
    let license = undefined;
    if (verifySourceCode) {
        license = getLicenseFromMetadata(contractInfo);
        (0, debug_1.default)(`License type: ${license}`);
    }
    if (opts.salt !== undefined) {
        (0, debug_1.default)(`Salt: ${opts.salt}`);
    }
    const deploymentRequest = {
        contractName: contractInfo.contractName,
        contractPath: contractInfo.sourceName,
        network: network,
        artifactPayload: JSON.stringify(contractInfo.buildInfo),
        licenseType: license, // cast without validation but catch error from API below
        constructorInputs: constructorArgs,
        verifySourceCode: verifySourceCode,
        relayerId: opts.relayerId,
        salt: opts.salt,
        createFactoryAddress: opts.createFactoryAddress,
        txOverrides: (0, utils_1.parseTxOverrides)(opts.txOverrides),
        libraries: contractInfo.libraries,
    };
    let deploymentResponse;
    try {
        deploymentResponse = await client.deployContract(deploymentRequest);
    }
    catch (e) {
        if (e.response?.data?.message?.includes('licenseType should be equal to one of the allowed values')) {
            throw new upgrades_core_1.UpgradesError(`License type ${license} is not a valid SPDX license identifier for block explorer verification.`, () => 'Specify a valid SPDX-License-Identifier in your contract.');
        }
        else {
            throw e;
        }
    }
    // For EOA or Safe deployments, address and/or txHash are not known until the deployment is completed.
    // In this case, prompt the user to submit the deployment in Defender, and wait for it to be completed.
    if (deploymentResponse.address === undefined || deploymentResponse.txHash === undefined) {
        console.log(`ACTION REQUIRED: Go to https://defender.openzeppelin.com/v2/#/deploy to submit the pending deployment.`);
        console.log(`The process will continue automatically when the pending deployment is completed.`);
        console.log(`Waiting for pending deployment of contract ${contractInfo.contractName} with deployment id ${deploymentResponse.deploymentId}...`);
        const pollInterval = opts.pollingInterval ?? 5e3;
        while (deploymentResponse.address === undefined || deploymentResponse.txHash === undefined) {
            (0, debug_1.default)(`Waiting for deployment id ${deploymentResponse.deploymentId} to return address and txHash...`);
            await new Promise(resolve => setTimeout(resolve, pollInterval));
            deploymentResponse = await client.getDeployedContract(deploymentResponse.deploymentId);
        }
    }
    const txResponse = (await hre.ethers.provider.getTransaction(deploymentResponse.txHash)) ?? undefined;
    const checksumAddress = hre.ethers.getAddress(deploymentResponse.address);
    return {
        address: checksumAddress,
        txHash: deploymentResponse.txHash,
        deployTransaction: txResponse,
        remoteDeploymentId: deploymentResponse.deploymentId,
    };
}
exports.defenderDeploy = defenderDeploy;
async function getContractInfo(hre, factory, opts) {
    let fullContractName, runValidation;
    let libraries;
    try {
        // Get fully qualified contract name and link references from validations
        const deployData = await (0, deploy_impl_1.getDeployData)(hre, factory, opts);
        [fullContractName, runValidation] = (0, upgrades_core_1.getContractNameAndRunValidation)(deployData.validations, deployData.version);
        (0, debug_1.default)(`Contract ${fullContractName}`);
        // Get externally linked libraries
        const linkReferences = runValidation[fullContractName].linkReferences;
        for (const ref in linkReferences) {
            const linkedBytes = factory.bytecode.slice(2);
            const start = linkReferences[ref].start * 2;
            const length = linkReferences[ref].length * 2;
            const linkFullyQualifiedName = `${linkReferences[ref].src}:${linkReferences[ref].name}`;
            const linkAddress = `0x${linkedBytes.substring(start, start + length)}`;
            libraries ?? (libraries = {});
            libraries[linkFullyQualifiedName] = linkAddress;
        }
        (0, debug_1.default)(`Libraries: ${JSON.stringify(libraries, null, 2)}`);
    }
    catch (e) {
        if (e instanceof upgrades_core_2.ContractSourceNotFoundError) {
            // Proxy contracts would not be found in the validations, so try to get these from the plugin's precompiled artifacts.
            for (const artifact of deployableProxyContracts) {
                if (artifact.bytecode === factory.bytecode) {
                    const sourceName = artifact.sourceName;
                    const contractName = artifact.contractName;
                    const buildInfo = build_info_v5_json_1.default;
                    (0, debug_1.default)(`Proxy contract ${sourceName}:${contractName}`);
                    return { sourceName, contractName, buildInfo };
                }
            }
        }
        // If nothing else worked, re-throw error about the contract not being found.
        throw e;
    }
    const { sourceName, contractName } = (0, contract_names_1.parseFullyQualifiedName)(fullContractName);
    // Get the build-info file corresponding to the fully qualified contract name
    const buildInfo = await hre.artifacts.getBuildInfo(fullContractName);
    if (buildInfo === undefined) {
        throw new upgrades_core_1.UpgradesError(`Could not get Hardhat compilation artifact for contract ${fullContractName}`, () => `Run \`npx hardhat compile\``);
    }
    return { sourceName, contractName, buildInfo, libraries };
}
/**
 * Get the license type from the contract metadata without validating its validity, except converts undefined or UNLICENSED to None.
 */
function getLicenseFromMetadata(contractInfo) {
    const compilerOutput = contractInfo.buildInfo.output.contracts[contractInfo.sourceName][contractInfo.contractName];
    const metadataString = compilerOutput.metadata;
    if (metadataString === undefined) {
        throw new upgrades_core_1.UpgradesError('License type could not be determined from contract metadata', () => 'Enable metadata output in your compiler settings.');
    }
    const metadata = JSON.parse(metadataString);
    const license = metadata.sources[contractInfo.sourceName].license;
    if (license === undefined || license === 'UNLICENSED') {
        // UNLICENSED means no license according to solidity docs
        return 'None';
    }
    else {
        return license;
    }
}
//# sourceMappingURL=deploy.js.map