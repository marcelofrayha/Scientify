"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FoundryRunner = exports.HardhatFoundryError = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const errors_1 = require("hardhat/internal/core/errors");
const os_1 = __importDefault(require("os"));
const util_1 = require("util");
const exec = (0, util_1.promisify)(child_process_1.exec);
class HardhatFoundryError extends errors_1.NomicLabsHardhatPluginError {
    constructor(message, parent) {
        super("hardhat-foundry", message, parent);
    }
}
exports.HardhatFoundryError = HardhatFoundryError;
class ForgeInstallError extends HardhatFoundryError {
    constructor(dependency, parent) {
        super(`Couldn't install '${dependency}', please install it manually.

${parent.message}
`, parent);
    }
}
function runningOnWindows() {
    return os_1.default.platform() === "win32";
}
class FoundryRunner {
    constructor(_forgeCommand) {
        this._forgeCommand = _forgeCommand;
    }
    static create() {
        if (FoundryRunner._instance !== undefined) {
            return FoundryRunner._instance;
        }
        const potentialForgeCommands = ["forge"];
        if (runningOnWindows()) {
            potentialForgeCommands.push("%USERPROFILE%\\.cargo\\bin\\forge");
        }
        else {
            potentialForgeCommands.push("~/.foundry/bin/forge");
        }
        console.log("[Issue 449] Potential forge commands:", potentialForgeCommands);
        for (const potentialForgeCommand of potentialForgeCommands) {
            try {
                (0, child_process_1.execSync)(`${potentialForgeCommand} --version`, {
                    stdio: "pipe",
                }).toString();
                FoundryRunner._instance = new FoundryRunner(potentialForgeCommand);
                console.log(`[Issue 449] '${potentialForgeCommand}' worked`);
                return FoundryRunner._instance;
            }
            catch (error) {
                console.log(`[Issue 449] '${potentialForgeCommand}' didn't work:`, error.message, `(code: ${error.status}})`);
                if (error.status === 127 || // unix
                    error.toString().includes("is not recognized") === true || // windows (code: 1)
                    error.toString().includes("cannot find the path") === true // windows (code: 1)
                ) {
                    // command not found, then try the next potential command
                    continue;
                }
                else {
                    // command found but execution failed
                    throw error;
                }
            }
        }
        console.log("[Issue 449] No command worked");
        throw new HardhatFoundryError(`Couldn't find forge binary. Performed lookup: ${JSON.stringify(potentialForgeCommands)}`);
    }
    getForgeConfig() {
        return JSON.parse(runCmdSync(`${this._forgeCommand} config --json`));
    }
    async getRemappings() {
        // Return remappings if they were already loaded
        if (this._cachedRemappings !== undefined) {
            return this._cachedRemappings;
        }
        // Get remappings from foundry
        const remappingsTxt = await runCmd(`${this._forgeCommand} remappings`);
        const remappings = {};
        const remappingLines = remappingsTxt.split(/\r\n|\r|\n/);
        for (const remappingLine of remappingLines) {
            const fromTo = remappingLine.split("=");
            if (fromTo.length !== 2) {
                continue;
            }
            const [from, to] = fromTo;
            // source names with "node_modules" in it have special treatment in hardhat core, so we skip them
            if (to.includes("node_modules")) {
                continue;
            }
            remappings[from] = to;
        }
        this._cachedRemappings = remappings;
        return remappings;
    }
    async installDependency(dependency) {
        const cmd = `${this._forgeCommand} install --no-commit ${dependency}`;
        console.log(`Running '${chalk_1.default.blue(cmd)}'`);
        try {
            await exec(cmd);
        }
        catch (error) {
            throw new ForgeInstallError(dependency, error);
        }
    }
}
exports.FoundryRunner = FoundryRunner;
function runCmdSync(cmd) {
    try {
        return (0, child_process_1.execSync)(cmd, { stdio: "pipe" }).toString();
    }
    catch (error) {
        const pluginError = buildForgeExecutionError(error.status, error.stderr.toString());
        throw pluginError;
    }
}
async function runCmd(cmd) {
    try {
        const { stdout } = await exec(cmd);
        return stdout;
    }
    catch (error) {
        throw buildForgeExecutionError(error.code, error.message);
    }
}
function buildForgeExecutionError(exitCode, message) {
    switch (exitCode) {
        case 127:
            return new HardhatFoundryError("Couldn't run `forge`. Please check that your foundry installation is correct.");
        case 134:
            return new HardhatFoundryError("Running `forge` failed. Please check that your foundry.toml file is correct.");
        default:
            return new HardhatFoundryError(`Unexpected error while running \`forge\`: ${message}`);
    }
}
//# sourceMappingURL=foundry.js.map